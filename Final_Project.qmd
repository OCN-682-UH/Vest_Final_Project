---
title: "SGD Toolbox"
subtitle: "Final Project OCN 682"
author: "Jordan Vest"
date: today
title-block-banner: ".jpg"
format:
  html:
    theme: flatly
    toc: true
    toc-depth: 3
    toc-location: left
    code-fold: true
    code-tools: true
    df-print: paged
editor: visual
execute:
  freeze: auto
  message: false
  warning: false
  echo: true
---

```{r}
#| label: plot-example-2
#| echo: true
#| fig-width: 7
#| fig-height: 5
#| message: false
#| warning: false
```

# Introduction
This data was collected by the Silbiger Lab and colleagues as a part of their work with the Mo'orea LTER (Long-term Ecological Research) site. Two SGD seeps were identified (Cabral and Varari) and sampled in [August 2022](https://github.com/njsilbiger/MooreaSGD_site-selection/tree/b7611bcbeecee570db6f932567a8af70bb174953/Data/August2022) and [March 2022](https://github.com/njsilbiger/MooreaSGD_site-selection/tree/b7611bcbeecee570db6f932567a8af70bb174953/Data/March2022). The seep was identified and ~20 sampling sites were selected along the gradient of SGD influence.

I used both the Nutrients collected via water sampling and the Turbinaria isotope data. 


*Turbinaria ornata* is a common brown macroalga in high-SGD regions across French Polynesia.
Because its N and C isotope ratios reflect ambient nutrient conditions, it serves as a good proxy for the long-term effects of groundwater-derived nutrients.
Water column nutrients which include Nitrite, Ammonium, Silicate, and Phosphate were collected across seasonal, tidal, and diel cycles and give us a better picture at the short term shifts in SGD influence. 

This dashboard explores:

* seasonal nutrient differences

* tidal nutrient pulsing

* nutrient–isotope relationships

* spatial patterns of SGD

# Data Preparation

## Load Libraries
```{r}
library(tidyverse)
library(here)
library(leaflet) 
library(dplyr)
library(RColorBrewer)
library(ggridges)
```

## Load Data
```{r}
Turb_M <- read_csv(here("Data", "Turb_NC_March.csv"))%>% 
  mutate(Season = "March")
Turb_A <- read_csv(here("Data", "Turb_NC_August.csv"))%>% 
  mutate(Season = "August")
Nutrients_M <- read_csv(here("Data", "Nutrients_watersampling_Mar22.csv"))%>% 
  mutate(Season = "March")
Nutrients_A <- read_csv(here("Data", "Nutrients_Watersampling_Aug21.csv"))%>% 
  mutate(Season = "August")
allbiogeochem_M <- read_csv(here("Data", "Allbiogeochemdata_QC_march.csv"))%>% 
  select(CowTagID, lat, lon)%>% 
  distinct(CowTagID, .keep_all = TRUE) %>%
  rename(lng = lon)
```

## Merge Data
### Isotopes
```{r}
#merge seasonal datasets into one, select columns of interest, join with coordinates from allbiogeochem
Turb_master <- bind_rows(Turb_M, Turb_A) %>%
    select(
        CowTagID,
        N_ug,
        del15N,
        C_ug,
        del13C,
        N_percent,
        C_percent,
        C_N,
        Season
    ) %>%
    left_join(allbiogeochem_M, by = "CowTagID")

Turb_master
```

### Nutrients
```{r}
#merge, select, join coordinate data
Nutrients_master <- bind_rows(Nutrients_M, Nutrients_A) %>%
    select(
      CowTagID,
      Day_Night,
      Tide,
      Phosphate_umolL,
      Silicate_umolL,
      Nitrite_umolL,
      Ammonia_umolL,
      Season
  ) %>%
  left_join(allbiogeochem_M, by = "CowTagID") 

Nutrients_master
```

### Master Dataframe 
```{r}
Master_all <- Nutrients_master %>%
  left_join(
    Turb_master %>%
      select(
        CowTagID,
        Season,
        N_ug, del15N, C_ug, del13C,
        N_percent, C_percent, C_N
      ),
    by = c("CowTagID", "Season")
  )

Master_all
```

# Diagnostic Nutrient Dashboard
## Nutrient summary function

```{r}
summarize_nutrients <- function(df) {
  wide <- df %>%
    group_by(CowTagID, Season, Tide) %>%
    summarize(
      lat       = first(lat),
      lng       = first(lng),
      PO4       = mean(Phosphate_umolL, na.rm = TRUE),
      SiO2      = mean(Silicate_umolL, na.rm = TRUE),
      NO3       = mean(Nitrite_umolL, na.rm = TRUE),
      NH4       = mean(Ammonia_umolL, na.rm = TRUE),
      .groups = "drop"
    )
  
  long <- wide %>%
    pivot_longer(cols = PO4:NH4,
                 names_to = "Nutrient",
                 values_to = "Mean_value")
  
  list(wide = wide, long = long)
}
```
I wanted a single function that could handle both output types.

Grouping by CowTagID × Season × Tide ensures all summaries are consistent


### Call the function
```{r}
Nutrients_summary <- summarize_nutrients(Nutrients_master)

# Access wide table for mapping
Nutrients_summary$wide
```
Wide allows for each nutrient to get its own column. Useful for mapping later on

```{r}
# Access long table for plotting
Nutrients_summary$long
```
For plotting, a long format is more convenient

## Master Dataframe Summary 
Repeat the process for the Master Dataframe
```{r}
summarize_master <- function(df) {
  wide <- df %>%
    group_by(CowTagID, Season, Tide) %>%
    summarize(
      lat  = first(lat),
      lng  = first(lng),
      # Nutrients
      PO4  = mean(Phosphate_umolL, na.rm = TRUE),
      SiO2 = mean(Silicate_umolL, na.rm = TRUE),
      NO3  = mean(Nitrite_umolL, na.rm = TRUE),
      NH4  = mean(Ammonia_umolL, na.rm = TRUE),
      # Isotopes
      del15N = mean(del15N, na.rm = TRUE),
      del13C = mean(del13C, na.rm = TRUE),
      .groups = "drop"
    )
  long <- wide %>%
    pivot_longer(cols = PO4:del13C,
                 names_to = "Nutrient",
                 values_to = "Mean_value")
  
  list(wide = wide, long = long)
}
```

```{r}
Master_summary <- summarize_master(Master_all)
```

```{r}
Master_summary$long
```


## Nutrient Distributions
### Q1: How do nutrient concentrations (Nitrite) vary by season and tide?

```{r}
Master_all %>%
  filter(!is.na(Nitrite_umolL), !is.na(Tide), !is.na(Season), Tide %in% c("High", "Low")) %>%
  mutate(
    Tide = factor(Tide, levels = c("High", "Low"))
  ) %>%
  ggplot(aes(
    x = Nitrite_umolL,
    y = Tide,
    fill = Season
  )) +
  geom_density_ridges(
    alpha = 0.6,
    scale = 1.4,
    color = "white"
  ) +
  coord_cartesian(xlim = c(0, 3)) +
  scale_fill_brewer(palette = "Dark2") +
  labs(
    title = "Nitrite Distribution by Tide and Season",
    x = "Nitrite (µmol/L)",
    y = "Tide Stage",
    fill = "Season"
  ) +
  theme_minimal(base_size = 14)
```


This ridgeline plot shows the distribution of **Nitrite** at **High** and **Low** tide for March and August.  

- The peaks are shifted toward **higher Nitrite at Low tide** compared to High tide, especially in March.  
- Most values fall below 3 µmol L⁻¹ (the range shown here), but there are known extreme seep values beyond this range that are not visible in this truncated view.  
- Overall, this supports the idea that **SGD-driven Nitrite is more pronounced at Low tide**, when groundwater influence on the reef flat is strongest, with March showing slightly higher and more skewed Nitrite than August.

### Q2: Do algae isotopes (δ15N) track Nitrite gradients?
```{r}
del15N_vs_Nitrite_raw <- Master_all %>%
filter(
!is.na(del15N),
!is.na(Nitrite_umolL),
!is.na(Season)
) %>%
ggplot(aes(x = Nitrite_umolL, y = del15N, color = Season)) +
geom_point(alpha = 0.7, size = 2.5) +
geom_smooth(method = "lm", se = FALSE, color = "black") +
coord_cartesian(xlim = c(0, 5)) +  # focus on main range; extremes exist beyond 5
labs(
title = "Turbinaria δ15N vs Nitrite (raw samples)",
x = "Nitrite (µmol/L)",
y = "δ15N (‰)"
) +
theme_minimal(base_size = 14)

del15N_vs_Nitrite_raw
```
This scatterplot uses **raw samples** so each point is a Turbinaria sample paired with Nitrite at that site and time.  

- δ¹⁵N tends to **increase with Nitrite**, consistent with enriched nitrogen sources (e.g., groundwater or anthropogenic inputs) influencing both the water column and the macroalgae.  
- The black line is a linear fit across both seasons; the positive slope suggests a general relationship between higher Nitrite and enriched δ¹⁵N.  
- Differences between March and August indicate that the **strength of this signal is seasonally modulated**, but the overall pattern supports the use of Turbinaria δ¹⁵N as a proxy for long-term nutrient conditions.

### Summary table: VSEEP Tide x Season
```{r}
vseep_summary <- Master_all %>%
filter(CowTagID == "VSEEP") %>%
group_by(Season, Tide) %>%
summarize(
Nitrite_mean = mean(Nitrite_umolL, na.rm = TRUE),
Ammonia_mean = mean(Ammonia_umolL, na.rm = TRUE),
Phosphate_mean = mean(Phosphate_umolL, na.rm = TRUE),
Silicate_mean = mean(Silicate_umolL, na.rm = TRUE),
del15N_mean = mean(del15N, na.rm = TRUE),
del13C_mean = mean(del13C, na.rm = TRUE),
.groups = "drop"
)

vseep_summary
```
Mean nutrient concentrations and Turbinaria isotope values at seep site VSEEP, summarized by Season and Tide.

# Maps

## SGD Map
```{r}
# ============================================================
# make_sgd_map_summary()
# ------------------------------------------------------------
# PURPOSE:
#   Build an interactive leaflet map showing nutrient and isotope
#   patterns for a single season (March or August). This map lets
#   us visually assess how groundwater-driven nutrient enrichment
#   varies in *space* across the sampling gradient.
#
# WHY THIS MATTERS (FOR YOUR PRESENTATION):
#   SGD is spatially patchy. Nutrients and isotopes often show
#   clear patterns along a seep–offshore gradient. A map lets us
#   see:
#      • which sites are nutrient hotspots (e.g., VSEEP)
#      • how signals change down-gradient
#      • whether March and August differ spatially
#   This map is one of your “storytelling” outputs.
#
# INPUTS:
#   df_summary  - the output list from summarize_master()
#                 We use the $wide table (one row per site per tide per season).
#   season      - "March" or "August"
#
# OUTPUT:
#   A leaflet map with toggleable layers for:
#     • PO4, SiO2, Nitrite (NO3), Ammonium
#     • δ15N
#     • δ13C
#     • Site labels
#
# NOTES ON GOOGLE SATELLITE:
#   - Google tiles require an API key.
#   - You set the key in your R session (NOT in code), so it is private.
#   - When the map is knitted to HTML, the tiles load from the embedded URL.
#   - The key will be visible in the HTML, so DO NOT commit the HTML to GitHub.
# ============================================================

make_sgd_map_summary <- function(df_summary, season = "March") {

  # ---- Load required libraries ----
  library(dplyr)
  library(leaflet)
  library(RColorBrewer)

  # ============================================================
  # 1. EXTRACT AND FILTER DATA
  # ------------------------------------------------------------
  # summarize_master() returns a list with
  #   • $wide  (wide-format table)
  #   • $long  (long-format table)
  #
  # Here we only need the wide version because:
  #   • Each row is already 1 site × 1 tide × 1 season,
  #   • All nutrient/isotope variables are columns.
  # ============================================================

  df <- df_summary$wide
  df_season <- df %>% filter(Season == season)

  # ============================================================
  # 2. CREATE COLOR PALETTES
  # ------------------------------------------------------------
  # WHY?
  #   Each nutrient and isotope is continuous and requires a
  #   gradient color scale. Using palettes that reinforce the
  #   scientific meaning helps communicate the signal:
  #     • BuPu  = “cool to warm” for nutrients
  #     • YlOrRd = typical for heavy isotope enrichment
  #     • Blues  = δ13C fingerprints (light → darker C values)
  #
  # HOW DOMAINS ARE CHOSEN:
  #   Here we simply use the min/max from this season’s dataset.
  #   (More complex maps sometimes scale excluding extreme seeps.)
  # ============================================================
# ============================================================
# UPDATED COLOR PALETTES (flipped correctly)
# ------------------------------------------------------------
# δ15N:
#   Lowest values = pale yellow
#   Highest values = deep red
#
# δ13C:
#   Values are negative; closer to -8 should be pale/white,
#   and -16 should be dark blue.
#
# IMPORTANT:
#   - For δ15N we reverse the YlOrRd scale so yellow = low.
#   - For δ13C we reverse BOTH the scale AND numerical domain
#     so the legend goes:
#          -8   (light)
#          ...
#         -16   (dark)
# ============================================================

# Nutrients stay the same:
pal_nut <- colorNumeric(
  brewer.pal(9, "BuPu"),
  domain = unlist(df_season %>% select(PO4, SiO2, NO3, NH4)),
  na.color = "transparent"
)

# δ15N  (flip palette so yellow = low)
pal_d15 <- colorNumeric(
  brewer.pal(9, "YlOrRd"),   # NOT reversed anymore — now correct light→dark
  domain = df_season$del15N, # TRUE domain ensures legend goes low→high
  na.color = "transparent"
)

# δ13C  (flip palette AND domain)
# Domain must run from HIGH (least negative) to LOW (most negative)
d13_min <- min(df_season$del13C, na.rm = TRUE)
d13_max <- max(df_season$del13C, na.rm = TRUE)

# Reverse Blues so LIGHT = high values (−8), DARK = low (−16)
pal_d13 <- colorNumeric(
  palette = rev(brewer.pal(9, "Blues")),
  domain  = c(d13_max, d13_min),   # IMPORTANT: domain must be high → low
  na.color = "transparent"
)


  # ============================================================
  # 3. PRECOMPUTE COLORS FOR EACH POINT
  # ------------------------------------------------------------
  # WHY?
  #   Leaflet allows you to pass hex colors directly. Precomputing
  #   them improves readability and ensures no palette mismatch.
  #
  #   These new columns (e.g., PO4_col) store the actual color
  #   for each point based on its concentration.
  # ============================================================

  df_season <- df_season %>%
    mutate(
      PO4_col  = pal_nut(PO4),
      SiO2_col = pal_nut(SiO2),
      NO3_col  = pal_nut(NO3),  # Your dataset uses NO3 for Nitrite
      NH4_col  = pal_nut(NH4),
      del15N_col = pal_d15(del15N),
      del13C_col = pal_d13(del13C)
    )

  # ============================================================
  # 4. POPUP FUNCTION
  # ------------------------------------------------------------
  # WHY?
  #   Each Marker popup gives detailed values for that point.
  #   Domain experts (like your advisor) want exact numbers.
  #
  #   The popup shows:
  #     • site ID
  #     • tide
  #     • all nutrient concentrations
  #     • δ15N and δ13C
  #
  #   This reinforces the “diagnostic dashboard” framing.
  # ============================================================

  popup_fun <- function(row) {
    sprintf(
      "<b>CowTagID:</b> %s<br>
       <b>Tide:</b> %s<br><br>
       <b>PO4:</b> %.3f µmol/L<br>
       <b>SiO2:</b> %.3f µmol/L<br>
       <b>Nitrite:</b> %.3f µmol/L<br>
       <b>NH4:</b> %.3f µmol/L<br><br>
       <b>δ15N:</b> %.2f ‰<br>
       <b>δ13C:</b> %.2f ‰",
      row$CowTagID, row$Tide,
      row$PO4, row$SiO2, row$NO3, row$NH4,
      row$del15N, row$del13C
    )
  }

  # ============================================================
  # 5. BASEMAP — GOOGLE SATELLITE
  # ------------------------------------------------------------
  # This is the real map you want.
  #
  # HOW IT WORKS:
  #   • You set your API key locally via:
  #       Sys.setenv(GOOGLE_MAPS_API_KEY = “yourkey”)
  #   • Leaflet embeds the tile URL with your key in the HTML.
  #   • Anyone opening the HTML will see the Google imagery.
  #
  # IMPORTANT:
  #   Do NOT commit the knitted HTML to GitHub.
  #
  # OPTIONAL FALLBACK:
  #   If no key is found, you *could* use Esri Imagery,
  #   but here we keep it simple and use Google only.
  # ============================================================

  google_key <- Sys.getenv("GOOGLE_MAPS_API_KEY")

  google_sat_tile <- paste0(
    "https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}&key=",
    google_key
  )

  m <- leaflet(df_season) %>%
    addTiles(urlTemplate = google_sat_tile, attribution = "Google") %>%
    setView(
      lng = mean(df_season$lng, na.rm = TRUE),
      lat = mean(df_season$lat, na.rm = TRUE),
      zoom = 12
    )

  # ============================================================
  # 6. NUTRIENT OVERLAY LAYERS
  # ------------------------------------------------------------
  # WHY?
  #   Each nutrient gets its own togglable layer so the user can:
  #     • isolate patterns
  #     • compare nutrients
  #     • declutter the visual field
  #
  #   Grouping by nutrient allows true “dashboard-like” behavior.
  # ============================================================

  nutrient_vars <- c("PO4","SiO2","NO3","NH4")
  nutrient_cols <- c("PO4_col","SiO2_col","NO3_col","NH4_col")

  for (i in seq_along(nutrient_vars)) {
    v <- nutrient_vars[i]
    colname <- nutrient_cols[i]
    m <- m %>%
      addCircleMarkers(
        lng = ~lng, lat = ~lat,
        fillColor = df_season[[colname]],
        color = NA,
        fillOpacity = 0.9,
        radius = 6,
        group = v,        # for toggling
        popup = ~popup_fun(df_season)
      )
  }

  # ============================================================
  # 7. ISOTOPE LAYERS
  # ------------------------------------------------------------
  # WHY δ15N and δ13C?
  #   These reflect *integrated* nutrient conditions over time,
  #   complementing short-term water-column nutrient snapshots.
  #
  #   δ15N is often elevated in groundwater/terrestrial nitrogen.
  #   δ13C reflects carbon sourcing and metabolic context.
  #
  #   Plotting them spatially shows:
  #     • how long-term signals align with seep gradients
  #     • how isotopes differ from instantaneous water chemistry
  # ============================================================

  m <- m %>%
    addCircleMarkers(
      lng = ~lng, lat = ~lat,
      fillColor = ~del15N_col, color = "white",
      radius = 8, weight = 1, fillOpacity = 1,
      group = "δ15N",
      popup = ~popup_fun(df_season)
    ) %>%
    addCircleMarkers(
      lng = ~lng, lat = ~lat,
      fillColor = ~del13C_col, color = "white",
      radius = 8, weight = 1, fillOpacity = 1,
      group = "δ13C",
      popup = ~popup_fun(df_season)
    )

  # ============================================================
  # 8. LABELS FOR EACH SAMPLING SITE
  # ------------------------------------------------------------
  # WHY?
  #   Helps orient the viewer:
  #     • Which sites are seeps?
  #     • Which are downstream?
  #     • Where are Cabral vs Varari?
  #
  #   Labels are toggleable to reduce clutter.
  # ============================================================

  site_coords <- df_season %>%
    select(CowTagID, lat, lng) %>% distinct()

  m <- m %>%
    addCircleMarkers(
      data = site_coords,
      lng = ~lng, lat = ~lat,
      label = ~CowTagID,
      color = "black", fillColor = "white",
      radius = 10, fillOpacity = 0.9, weight = 1,
      clusterOptions = markerClusterOptions(),
      group = "Sites"
    )

  # ============================================================
  # 9. LAYER CONTROL
  # ------------------------------------------------------------
  # WHY?
  #   This is what makes the map usable during your talk.
  #   You can toggle:
  #     • PO4 / SiO2 / Nitrite / NH4
  #     • δ15N / δ13C
  #     • Site labels
  # ============================================================

  m <- m %>%
    addLayersControl(
      overlayGroups = c(nutrient_vars, "δ15N", "δ13C", "Sites"),
      options = layersControlOptions(collapsed = FALSE)
    ) %>%
    hideGroup(c(nutrient_vars, "δ15N", "δ13C"))

  # ============================================================
  # 10. LEGENDS
  # ------------------------------------------------------------
  # WHY?
  #   Legends connect the map’s color scales back to actual values.
  #   Without them, the map looks pretty but isn’t quantitative.
  # ============================================================

# ============================================================
# LEGENDS — UPDATED FOR CORRECT COLOR + VALUE ORDERING
# ------------------------------------------------------------
# δ15N:
#   Light yellow → low δ15N
#   Dark red → high δ15N
#
# δ13C:
#   Light color (top) → less negative (≈ -8‰)
#   Dark color (bottom) → more negative (≈ -16‰)
# ============================================================

m <- m %>%
  # ---- Nutrient Legend (unchanged) ----
  addLegend(
    position = "bottomleft",
    pal     = pal_nut,
    values  = unlist(df_season %>% select(PO4, SiO2, NO3, NH4)),
    title   = "Nutrients (µmol/L)",
  ) %>%

  # ---- δ15N Legend ----
  addLegend(
    position = "bottomright",
    pal     = pal_d15,
    values  = df_season$del15N,
    title   = "δ15N (‰)",
    opacity = 1,
  ) %>%

  # δ13C legend 
addLegend(
  position = "bottomleft",
  pal     = pal_d13,
  values  = c(d13_max, d13_min),   # TOP = −8, BOTTOM = −16
  title   = "δ13C (‰)",
)
  return(m)
}
```

```{r}
March_map3 <- make_sgd_map_summary(Master_summary, season = "March")
August_map3 <- make_sgd_map_summary(Master_summary, season = "August")
```

### March Map
```{r}
March_map3
```

### August Map
```{r}
August_map3
```

## I'm the other more complicated map that was a super cool idea but didn't work in the end :,(
```{r}
make_sgd_map <- function(
  df,
  season = "March",
  extreme_ids = c("CSPRING_BEACH2", "VSPRING", "VSEEP", "CSEEP") #tried to filter out the seeps so the gradients weren't so skewed...didn't work)
){

  # 1) Filter season
  df_season <- df %>% filter(Season == season)

  # 2) Stable site coordinates (one per CowTagID)
  site_coords <- df_season %>%
    group_by(CowTagID) %>%
    summarise(
      lat = median(lat, na.rm = TRUE),
      lng = median(lng, na.rm = TRUE),
      .groups = "drop"
    )

  # 3) Collapse to one row per CowTagID × Tide (means)
  df_collapse <- df_season %>%
    group_by(CowTagID, Tide) %>% # was trying to get a data point for each CowTagID at each tide
    summarise(
      Nitrite_umolL   = mean(Nitrite_umolL,   na.rm = TRUE),
      Ammonia_umolL   = mean(Ammonia_umolL,   na.rm = TRUE),
      Phosphate_umolL = mean(Phosphate_umolL, na.rm = TRUE),
      Silicate_umolL  = mean(Silicate_umolL,  na.rm = TRUE),
      del15N          = mean(del15N,          na.rm = TRUE),
      del13C          = mean(del13C,          na.rm = TRUE),
      .groups = "drop"
    ) %>%
    left_join(site_coords, by = "CowTagID")

  # 4) Palette domains computed WITHOUT extremes  # again trying to filter out those seeps and springs bc their nutrient values skew the whole gradient. The idea here was to create a reference dataset without the seeps and build the colar gradient from that. This way all the points would be plotted keep them plotted but not include the extremes in the color gradient, still didn't work
  ref <- df_collapse %>% filter(!CowTagID %in% extreme_ids)

#define a sorting helper
  safe_range <- function(x) { 
    x <- x[!is.na(x)]
    if (length(x) == 0) return(c(0, 1))
    r <- range(x)
    if (diff(r) == 0) r <- r + c(-0.5, 0.5) #arbitrary buffer 
    r
  }

  nut_domain <- safe_range(unlist(ref[c(
    "Nitrite_umolL","Ammonia_umolL","Phosphate_umolL","Silicate_umolL"
  )]))

  d15_domain <- safe_range(ref$del15N)
  d13_domain <- safe_range(ref$del13C)

  pal_nut  <- colorNumeric(brewer.pal(9,"BuPu"),  domain = nut_domain, na.color="transparent")
  pal_d15  <- colorNumeric(rev(brewer.pal(9,"YlOrRd")), domain = d15_domain, na.color="transparent")
  pal_d13  <- colorNumeric(brewer.pal(9,"Blues"), domain = d13_domain, na.color="transparent")

  # 5) Precompute color columns (hex strings) inside df_collapse
  #    This avoids evaluating bare symbols in palette calls later
  df_collapse <- df_collapse %>%
    mutate(
      Nitrite_col   = pal_nut(Nitrite_umolL),
      Ammonia_col   = pal_nut(Ammonia_umolL),
      Phosphate_col = pal_nut(Phosphate_umolL),
      Silicate_col  = pal_nut(Silicate_umolL),
      del15N_col    = pal_d15(del15N),
      # if del13C doesn't exist or is all-NA, pal_d13 will return NA; handle gracefully
      del13C_col    = if ("del13C" %in% names(df_collapse)) pal_d13(df_collapse$del13C) else NA_character_
    )

  # 6) Popup formatting
  fmt <- function(x) ifelse(is.na(x), "NA", format(round(x,3), trim=TRUE))

  df_collapse <- df_collapse %>%
    mutate(
      popup = sprintf(
        "<b>CowTagID:</b> %s<br><b>Tide:</b> %s<br><br>
         <b>Nitrite:</b> %s µmol/L<br>
         <b>Ammonia:</b> %s µmol/L<br>
         <b>Phosphate:</b> %s µmol/L<br>
         <b>Silicate:</b> %s µmol/L<br><br>
         <b>δ15N:</b> %s ‰<br>
         <b>δ13C:</b> %s ‰",
        CowTagID, Tide,
        fmt(Nitrite_umolL), fmt(Ammonia_umolL),
        fmt(Phosphate_umolL), fmt(Silicate_umolL),
        fmt(del15N), fmt(del13C)
      )
    )

  # 7) Split by tide
  df_high <- df_collapse %>% filter(Tide == "High")
  df_low  <- df_collapse %>% filter(Tide == "Low")

  # 8) Build base leaflet map
  google_api_key <- "AIzaSyDdjKN13QuRrg_xhVYX7lCho0AoUa6Jpws"
  google_sat_tile <- paste0(
    "https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}&key=", google_api_key
  )

  m <- leaflet() %>%
    addTiles(urlTemplate = google_sat_tile, attribution = "Google") %>%
    setView(lng = mean(df_collapse$lng, na.rm = TRUE),
            lat = mean(df_collapse$lat, na.rm = TRUE),
            zoom = 12)

  # 9) Add nutrient layers (use vector of colors from precomputed columns)
  nutrient_vars <- c("Nitrite_umolL","Ammonia_umolL","Phosphate_umolL","Silicate_umolL")
  nutrient_cols <- c("Nitrite_col","Ammonia_col","Phosphate_col","Silicate_col")

  add_layers <- function(map, data, tide_label){
    if (nrow(data) == 0) return(map)
    # nutrients
    for(i in seq_along(nutrient_vars)){
      v <- nutrient_vars[i]
      colname <- nutrient_cols[i]
      map <- map %>%
        addCircleMarkers(
          data = data,
          lng = ~lng, lat = ~lat,
          fillColor = data[[colname]],
          color = NA, fillOpacity = 0.9, radius = 6,
          group = c(v, tide_label),
          popup = ~popup
        )
    }
    # isotopes
    map <- map %>%
      addCircleMarkers(
        data = data, lng = ~lng, lat = ~lat,
        fillColor = data[["del15N_col"]],
        color = "white", radius = 8, weight = 1, fillOpacity = 1,
        group = c("δ15N", tide_label), popup = ~popup
      ) %>%
      addCircleMarkers(
        data = data, lng = ~lng, lat = ~lat,
        fillColor = data[["del13C_col"]],
        color = "white", radius = 8, weight = 1, fillOpacity = 1,
        group = c("δ13C", tide_label), popup = ~popup
      )

    map
  }

  m <- add_layers(m, df_high, "High")
  m <- add_layers(m, df_low,  "Low")

  # 10) Add centroids
  m <- m %>%
    addCircleMarkers(
      data = site_coords,
      lng = ~lng, lat = ~lat, label = ~CowTagID,
      color = "black", fillColor = "white", radius = 10,
      fillOpacity = 0.9, weight = 1,
      clusterOptions = markerClusterOptions(),
      group = "Sites"
    )

  # 11) Layer control + hide nutrients by default
  overlay_groups <- c("High","Low",
                      nutrient_vars,
                      "δ15N","δ13C","Sites")

  m <- m %>%
    addLayersControl(
      overlayGroups = overlay_groups,
      options = layersControlOptions(collapsed = FALSE)
    ) %>%
    hideGroup(c(nutrient_vars, "δ15N","δ13C"))

  # 12) Legends (use domains used for palettes)
  m %>%
    addLegend(position = "bottomleft", pal = pal_nut, values = nut_domain, title = "Nutrients", opacity = 1) %>%
    addLegend(position = "bottomright", pal = pal_d15, values = d15_domain, title = "δ15N", opacity = 1) %>%
    addLegend(position = "bottomleft", pal = pal_d13, values = d13_domain, title = "δ13C", opacity = 1)
}
```

```{r}
March_map  <- make_sgd_map(Master_all, season = "March")
August_map <- make_sgd_map(Master_all, season = "August")
```

```{r}
March_map
```

